# Atoms
const {ok} ();
const {nil} {};
const {true} 1;
const {false} 0;

# Unpack and Pack List for function
const {unpack} {f: func q: qexpr} -> {
	eval (join (list f) q)
};
const {pack} {f: func &xs: int} -> {f xs};
const {curry} unpack;
const {uncurry} pack;

const {do} {&q: any} -> {
	if (== q nil)
		{nil}
		{last q}
};

# Open a new scope
const {scope} {b: qexpr} -> {
	{_: any} -> b () # TODO: '{} -> b' should also work (although, it doesn't right now)
};

const {flip} {f: func a: any b: any} -> {f b a};

const {map} {f: func q: qexpr} -> {
	if (== q nil)
		{nil}
		{join (list (f (get 0 q))) (map f (tail q))}
};

const {isok} {a: any} -> {
	if (== a ok)
		{true} {false}
};

const {isnok} {a: any} -> {
	if (!= a ok)
		{true} {false}
};

const {iserr} {a: any} -> {
	if (== (typeof a) err)
		{true} {false}
};

const {iferrdo} {a: any f: func} -> {
	if (== (typeof a) err)
		{f a} {ok}
};

const {ghost} {&xs: any} -> {eval xs};

# Compose Functions Together
const {comp} {f: func g: func x: any} -> {f (g x)};

const {first_eval} (comp eval first);

const {filter} {f: func q: qexpr} -> {
	if (== q nil)
		{nil}
		{join (if (f (first_eval q)) {first q} {nil}) (filter f (tail q))}
};

def {foldl} {f: func z: any q: qexpr} -> {
	if (== q nil)
		{z}
		{foldl f (f z (first_eval q)) (tail q)}
};

def {sum} {q: qexpr} -> {foldl + 0 q};
def {product} {q: qexpr} -> {foldl * 1 q};

def {fib} {n: int} -> {
	if (== n 0) {0}
		(== n 1) {1}
		{+ (fib (- n 1)) (fib (- n 2))}
};