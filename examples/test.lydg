const {continue_or_quit} {_: any} -> { do
	(print)
	(print)
	(let {input} (read "-> Press ENTER to continue or CTRL-C to Quit! "))
	#(if (== input "q") {exit} {}) # TODO: Right now, 'exit' only works directly from the REPL
};

# -- Basic things
print "--- Basic Things ---";
print (+ 3 3);
def {x} 5;
print (if (== x 5) {"true"} {"false"});
print {x y non_existant_symbol};
print [(+ x 1) x {x non_existant_symbol}];
print (+ (+ x 1) x);
continue_or_quit ();
print;

# -- The 'typeof' Function
print "--- The 'typeof' Function ---";
print (typeof x);
print (typeof (typeof x));
print (typeof (typeof (typeof x)));
continue_or_quit ();
print;

# -- Getting input from user (and assigning to variable)
print "--- Input from User ---";
def {name} (read "Enter your name: ");
print "  -> Hello" name "!";
continue_or_quit ();
print;

# -- Function/Lambda declarations
print "--- Function/Lambda Declarations ---";
def {test} {x: int y: string} -> {print x y};
def {test2} {x: int y: string} -> {print x y}; # Same as 'test' function, just different syntax (using lambda's directly instead of the std lib function 'fn')
test 5 "string";
test2 5 "string";
continue_or_quit ();
print;

# -- Lambda evaluation
print "--- Lambda Evaluation ---";
def {x} {} -> {5}; # Since this lambda takes no arguments, it is automatically evaluated before being assigned to the variable (x).
print "x:" x;
def {isFunction} {x: any} -> {if (== (typeof x) func) {"a function"} {"not a function"}};
def {isInteger} {x: any} -> {if (== (typeof x) int) {"an integer"} {"not an integer"}};
print "x is" (isFunction x);
print "x is" (isInteger x);
def {z} {y: int} -> {+ y 1};
print "z:" z;
print "z is" (isFunction z);
print "z is" (isInteger z);
print "(z 5):" (z 5);
continue_or_quit ();
print;

# -- Statements
print "--- Statements ---";
# (print 5; print 73;)   # This is not allowed!!!;
print 5; print 73;       # But this is allowed!
continue_or_quit ();
print;

# -- While Loop
print "--- While Loop ---";
def {x} 5;
scope {def {result} (while {(< x 20)} {do (print x) (let {x} (+ x 1))})};
print;
print "While loop result:" result;
print "x: " x;
continue_or_quit ();
print;

# -- The 'map' and 'filter' Functions
print "--- The 'map' and 'filter' Functions ---";
print "Mapping to lambda '{n: any} -> {+ n 1}': " (map ({n: any} -> {+ n 1}) {3 3 3 3});
print "Mapping to function '-': " (map - {3 3 3 3});
print "filter using lambda '{n: any} -> {> n 2}': " (filter ({n: any} -> {> n 2}) {5 2 11 -7 8 1});
continue_or_quit ();
print;

# -- The '==' Function
#    Returns true if first item is equal to any of the successive items.
#      Note that it doesn't have to be equal to all of them, as long as it is equal to at least one of them.
#      Examples of this are shown below:
print "--- The '==' Function ---";
print "(== 1 0) ->" (== 1 0);
print "(== 1 1) ->" (== 1 1);
print "(== 1 1 0) ->" (== 1 1 0);
print "(== 1 0 1) ->" (== 1 0 1);
print "(== 1 0 0) ->" (== 1 0 0);
continue_or_quit ();
print;

# -- The '!=' Function
#    Returns true if first item is not equal to ALL of the successive items.
#      It it is equal to any of them, even just one, it will return false (0).
#      Examples of this are shown below:
print "--- The '!=' Function ---";
print "(!= 1 0) ->" (!= 1 0);
print "(!= 1 1) ->" (!= 1 1);
print "(!= 1 1 0) ->" (!= 1 1 0);
print "(!= 1 0 1) ->" (!= 1 0 1);
print "(!= 1 0 0) ->" (!= 1 0 0);
print;